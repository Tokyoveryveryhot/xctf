使用IDA查看，发现是一道交互题，程序流程是先输入1登录，然后先后输入用户名，密码，接着进入check_passwd函数，该函数先检查输入的范围，如果在3u和8u之间，则显示success，并使用strcpy来赋值。
第一步，查看字符串，找到关键字符串cat flag，查看交叉引用，找到what_is_this函数，该函数调用_system("cat flag")函数，可以拿到flag
第二步，观察发现危险函数strcpy，因此我们需要着手修改char *s，使得赋值后dest的值可以覆盖返回地址，从dest的栈中发现其大小是14h，通过填充14h+4h个字符就可以实现缓冲区溢出。read(0, &s, 0x199u);s的大小为0x199，完全可以填充
第三步，v3的范围有限制，但根据定义发现unsigned __int8 v3，占8位，范围是0-255，可以通过整数溢出来实现
构造的payload为payload = "a"*0x14+"a"*4+p32(0x804868b)+"a"*(256-0x18-4)+"a"*4
其中0x14为数据空间的大小，4为ebp的大小，0x804868b为what_is_this函数的地址，由于总大小为256+4，因此还要填充256-0x18个字符。


1、在login()函数里，read()函数限制了程序只能读0x19即25个字节到字符串s中，也只能读409个字节到字符串buf中。但是，s距离ebp有28h即40个字节，buf距离ebp也有228h即552个字节，所以完全不可能覆盖ebp和函数返回地址。这决定了在这里不存在字符串溢出漏洞。
2、payload=20个字节的dest+4个字节的ebp+system函数地址+system函数的返回地址+用来凑够260字节的223个无用字节
