MIPS文件反汇编
不能使用F5查看伪代码
MIPS指令集
```
_4013C8:
lui     $v0, 0x4A	##将0x4A放到寄存器$vo的高十六位

addiu   $v1, $v0, (meow - 0x4A0000)  
# "cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ"

就是$v1=$v0+(meow-0x4A0000)
此时就是$v1=meow
（由注释可以猜测这里是弄进去个字符串首地址）


lw      $v0, 0x28+var_10($fp)

#从一个fp寄存器中读取一个字到$v0

addu    $v0, $v1, $v0

#v0=v1+v0（猜测，是读取字符串一个一个字符（常规都这样））
#那么猜测此时的v0就是第一个字符（后面递加），同样，可以猜测，v1就是递增数i，从0开始加。

lb      $v1, 0($v0)

#在$vo读取一个字节到v1中（猜测就是可疑字符串的那个东西）

#此时v1中的就是可疑字符串的第一位字符。

lw      $v0, 0x28+arg_4($fp)

#（猜测这是取自己输入的字符串的内容）

#在寄存器中读一个字（两字节）给v0

addiu   $v0, 4

#v0加4.（不知道有什么用）
#（猜测这是要加四位才是输入内容的第一字节）


lw      $a0, 0($v0)

#从v0去一个字到a0（那么这个时候a0中存的就是输入的第一个字）

lw      $v0, 0x28+var_10($fp)

#从一个寄存器中取一个字到v0（这里是前面猜测的那个i，用来逐个遍历变量的）

addu    $v0, $a0, $v0

#v0=a0+v0

lb      $v0, 0($v0)


#取一个字节到v0

xori    $v0, 0x37
#与0x37异或，然后放入$v0中。


sll     $v0, 24
v0左移24位

sra     $v0, 24
v0右移24位

上面两个就是取后八位的意思，就是取一个字节罗。

beq     $v1, $v0, loc_401428


不相等就跳转


move    $at, $at
```
把字符串取出与0x37进行异或，得到结果，代码：
```python
s = "cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ"

num = 0x37

for i in s:
 flag+=chr(num^ord(i))

print (flag)
#print(chr(ord(i)^num),end="")
```
