x64中，rdi向前兼容edi，edi向前兼容di，与之对应的是si，esi，rdi都是源变址寄存器，区别与di，edi，rdi类似。

x86/x64传参规则
    一个参数用rdi（edi）传
    两个参数用rdi、rsi（edi、esi）传
    三个参数用rdi、rsi、rdx（edi、esi、edx）传
    四个参数用rdi、rsi、rdx、rcx（edi、esi、edx、ecx）传
    五个参数用rdi、rsi、rdx、rcx、r8（edi、esi、edx、ecx、r8）传
    六个参数用rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）传


movsx：汇编语言 数据传送指令 MOV的变体。带符号扩展，并传送。

movzx：movzx一般用于将较小值拷贝到较大值中。这个指令是非常有用的，大家以后 学程序设计 的话，如果需要处理windows中的消息，例如WM_COMMAND消息，这个消息结构的wParam的高16位是通知码，而低16位则是命令id。有时候需要判断命令id的话，则需要将这个wparam的低16位扩展成32位的，并且其余位用0填充。这就用到了movzx。

MOVSX 先符号扩展,再传送。MOVZX 先零扩展,再传送。

符号扩展的意思是，当用很多的内存存储某一个有符号数时，由于符号位位于该数的第一位，扩展之后，符号位仍然需要位于第一位，所以，当扩展一个负数的时候需要将扩展的高位全赋为1.对于正数而言，符号扩展和零扩展是一样的，因为符号位就是0。

比如一个用一个8位二进制表示-1，则是10000001，如果把这个数用16位二进制表示时，则为11111111 10000001 高位全都是1，这个叫做符号扩展，主要用于对其操作数。零扩展就是全补零。

不论其符号位是多少，高8位全都补0。最后一句是r/m8后做符号扩展为16位后，送到reg16。

AND:按位逻辑与，结果放于目标操作数中：
X 	Y 	X^Y
0 	0 	0
0 	1 	0
1 	0 	0
1 	1 	1
TEST AX,BX 与 AND AX,BX 命令有相同效果，只是Test指令不改变AX和BX的内容，而AND指令会把结果保存到AX中。

在IDA中，流程图状态下按下/，返回到代码状态会在指令之上显示F5的注释



1、IDA放入ELF文件，可以看出程序逻辑：
在/tmp/flag.txt下建立一个文件，将flag写入文件中，最后remove删除这个文件。
2、使用gdb动态调试，发现在0x40081F处的指令执行结束后，会将flag的值写入到rdi寄存器中。


wp：
1、exeinfo pe查客和程序的详细信息
2、程序通过运算，最后将得到的flag写入文件。但是有意思的地方在flag.txt文件所在的位置是/tmp目录，这个目录是Linux下的临时文件夹，程序运行完，生成flag的txt文件被清理了，所以我们找不到文件
3、向下追踪，追踪到for循环的位置，因为，flag是在这里存入文件的，所以，我们可以在内存中找到正要存储的字符串
4、将鼠标指向strlen(),在下面可以看到汇编所在的地址，然后我们根据大概的地址去看汇编代码
5、根据F5插件的伪代码可以得出fputc(&(t+p[i]),stream)为将flag写入文件的关键代码，从而找到汇编语句mov eax,[rbp+var_3C]，进行动态调试。
5、知道经过for()的判断条件后，还要进行一步fseek函数，所以，根据汇编代码，可以确定jnb loc_4008B5就是fseek()函数，那么，mov eax,[rbp+var_3C]肯定就是最后要得到的flag了
6、  for ( i = 0; i < strlen(&t); ++i )
  {
    fseek(stream, p[i], 0);		//打开文件句柄，写入flag
    fputc(*(&t + p[i]), stream);
    fseek(stream, 0LL, 0);		//调整写文件的位置，再次回到开头位置，写入**********************,覆盖flag
    fprintf(stream, "%s\n", u);
  }


1、IDA动态调试，在34行remove的位置，F2下断点，查看tmp文件夹下flag.txt的内容，发现44个*号
2、原因是出在29行，在写完字符之后，写入*进行覆盖。想要获取真正的flag，其实就是28，29行，循环了strlen(t)次，每次都是取一个字符输入到文件中，也就是说t，就是存放flag的地方。
3、双击t，可以看到t变量在data段的地址为6010E0


1、程序整体流程如下：
声明变量v3,v5.........
对v5进行一系列计算
将变量u写入到文件flag.txt中
用************覆盖写入的flag
移除
文件在执行流程”将变量u写入到文件”时,我们发现一个比较特殊的地方.fprintf(stream, "%s\n", u, v5);fprintf函数的用法我专门去百度了以下,发现:第一个参数stream是要写入的文件第二个参数是写入形式后面两个参数是写入形式对应的变量

我们题中只给了一个格式输出符%s,但是我们有两个变量,按照我们实际上的用法,仅仅是将第一个变量u的内容输入到了stream中,而变量v5则就如同抛弃了一样.

writeup第三条对程序进行还原，得到代码如下：
int main()
{	
	int v6=0;
	char v3;
	char s[]="c61b68366edeb7bdce3c6820314b7498";
	char t[]="harifCTF{????????????????????????????????}";
	char *p=t;
	
	while ( v6 < strlen(s) )
  	{
    		if ( v6 & 1 )
      			v3 = 1;
    		else
      			v3 = -1;
    		*(p + v6 + 10) = s[v6] + v3;
    		v6 = v6 + 1;
  	}
	for(int i=0;i<strlen(t);i++)
		printf("%c",t[i]);
	return 0;
}
