1、使用exeinfo.PE查看文件信息与加壳情况
2、使用file命令查看具体信息
3、elf文件尝试运行
4、放入IDA中进行查看，找到Congratulations，从而找到main函数
根据  if ( strlen(&s1) != 24 || (v3 = "nctf{", strncmp(&s1, "nctf{", 5uLL)) || *(&byte_6010BF + 24) != 125 )在125的数字上按下R键变为字符，发现为'}'，该语句可看出输入的值为24且前5个字节为"nctf{"且最后一个字节为‘}’。
5、进入if判断语句，在数字上按下R键，语句为：

 if ( v4 > 78 )
 {
        v4 = v4;
        if ( v4 == 'O' )
        {
          v6 = sub_400650(&v9 + 1);
          goto LABEL_14;
        }
        if ( v4 == 'o' )
        {
          v6 = sub_400660(&v9 + 1);
          goto LABEL_14;
        }
}
else
{
        v4 = v4;
        if ( v4 == '.' )
        {
          v6 = sub_400670(&v9);
          goto LABEL_14;
        }
        if ( v4 == '0' )
        {
          v6 = sub_400680(&v9);
LABEL_14:
          v5 = v6;
          goto LABEL_15;
        }
}

其中的四个函数为：
//v9的下一字节减1
bool __fastcall sub_400650(_DWORD *a1)
{
  int v1; // eax@1

  v1 = (*a1)--;
  return v1 > 0;
}
//v9的下一字节加1
bool __fastcall sub_400660(int *a1)
{
  int v1; // eax@1

  v1 = *a1 + 1;
  *a1 = v1;
  return v1 < 8;
}
//v9减1
bool __fastcall sub_400670(_DWORD *a1)
{
  int v1; // eax@1

  v1 = (*a1)--;
  return v1 > 0;
}
//v9加1
bool __fastcall sub_400680(int *a1)
{
  int v1; // eax@1

  v1 = *a1 + 1;
  *a1 = v1;
  return v1 < 8;
}

不知为什么看出是迷宫问题
根据二维数组的性质，可以判断出
O对应左
o对应右
.对应上
0对应下
而这些函数传入的参数v9应该就是迷宫了
所以要找到迷宫

跟到label15的位置，出现asc_601060字符串，查看字符串的值：
asc_601060      db '  *******   *  **** * ****  * ***  *#  *** *** ***     *********',0
猜出是8*8的迷宫：
  ******
*   *  *
*** * **
**  * **
**  * **
*  *#  *
** *** *
**     *
********
终点是迷宫中心的#，起点是左上角的定点，走迷宫就能得到flag。


PS：迷宫问题特征：
1）在内存中放置“地图”
2）将用户输入限制为几个字符
3）通常只有一个迷宫入口和一个迷宫出口
该地图可以直接组成非常长的字符串，也可以一一排列。如果是逐行排列，由于迷宫一般较大，所以用于按线（注意，不按排列）按顺序排列，每行对应一个特定的行号，需要确定该行还原迷宫图的编号。安排迷宫的功能将重复很多次。
受限制的字符，例如作为组合w/s/a/d，h/j/k/l，l/r/u/d这样的类似组合。
通常，迷宫只有一个入口和一个出口，例如左上角(0, 0)位置的入口和右下角的出口(max_X, max_Y)。但是可能会有一个出口。在迷宫的中央，使用一个Y字符指示等。还要根据具体情况判断回答迷宫问题的条件。


迷宫问题：
https://ctf-wiki.github.io/ctf-wiki/reverse/maze/maze/
使用光标选择.rodata部分中所有地图字符串，之后按shift+E提取所有地图数据。