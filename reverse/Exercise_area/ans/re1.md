1、PEID打开，发现没有加壳
2、IDA反汇编打开，查看所有的字符串，找到flag get字符串，点击进入
3、使用F5插件，找到关键代码，代码逻辑为:
_mm_storeu_si128((__m128i *)&v4, _mm_loadu_si128((const __m128i *)&xmmword_413E34));
scanf("%s", (unsigned int)&v8);
v2 = strcmp((const char *)&v4, &v8);
if(v2==0)
    printf("flag get\n");

值得注意的是xmmword_413E34的位置不足，还需要qword_413E44。

v2 = -(v2 < 0) | 1;该语句的意思为v2如果小于0的话，v2的值为-1，否则v2的值为1
void _mm_store_si128 ( __m128i *p, __m128i a);可存储128位数据，将__m128i 变量a的值存储到p所指定的变量中去


wp:
1、LoadPE查壳不准确
2、_mm_storeu_si128(），对其进行分析发现它类似于memset(),将xmmword_413E34的值赋值给v5，所以，我们可以得到正确的flag应该在xmmword_413E34中，然后，我们双击413E34进行跟进。可以看到一堆十六进制的数
这时，我们使用IDA的另一个功能 R ，能够将十进制的数转换为字符串
3、大端与小端
假设一个十六进制数0x12345678
大端的存储方式是：12,34,56,78，然后读取的时候也是从前往后读
小端的存储方式是：78,56,34,12，然后读取的时候是从后往前读取


1、使用OD动态调试可直接找出flag
2、strings re1.exe | less

回应： 1.输入密码，给出flag
            2.如果是flag比对，回应一般是已经写在程序里了，用shift+F12查找字符串；一般是给出回应
            3.有的flag是程序运行给出，可以kali动态运行，或者读代码写出类似代码，如第二题game，写代码

这不就是传说中的flag吗？但是咋这么奇怪，逆序显示，这当然是大小端的问题了。那就是DUTCTF{We1c0met0，我擦嘞，只有一半。一般的套路就是第一个字符串没有\0，然后紧接着的另一个变量就是剩下的一半。刚好，有一个qword_413E44，也是一串十六进制。注意到v4和v5的栈空间相邻，可能分别存储了flag的两个片段